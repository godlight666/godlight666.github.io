<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>helloworld</title>
    <link href="/2022/06/30/DB_Notes/hello/"/>
    <url>/2022/06/30/DB_Notes/hello/</url>
    
    <content type="html"><![CDATA[<h1 id="this-is-a-test"><a href="#this-is-a-test" class="headerlink" title="this is a test"></a>this is a test</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CMU15-445 实验笔记</title>
    <link href="/2022/06/28/DB_Notes/README/"/>
    <url>/2022/06/28/DB_Notes/README/</url>
    
    <content type="html"><![CDATA[<h1 id="CMU15-445-实验笔记"><a href="#CMU15-445-实验笔记" class="headerlink" title="CMU15-445 实验笔记"></a>CMU15-445 实验笔记</h1><p>CMU15-445 fall 2021实验笔记</p><p>课程地址：<a href="https://15445.courses.cs.cmu.edu/fall2021/">https://15445.courses.cs.cmu.edu/fall2021/</a></p><p>完成情况：</p><ul><li><input disabled="" type="checkbox"> <a href="https://15445.courses.cs.cmu.edu/fall2021/project0/">PROJECT #0 - C++ PRIMER</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://15445.courses.cs.cmu.edu/fall2021/project1/">PROJECT #1 - BUFFER POOL</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://15445.courses.cs.cmu.edu/fall2021/project2/">PROJECT #2 - EXTENDIBLE HASH INDEX</a></li><li><input disabled="" type="checkbox"> <a href="https://15445.courses.cs.cmu.edu/fall2021/project3/">PROJECT #3 - QUERY EXECUTION</a></li><li><input disabled="" type="checkbox"> <a href="https://15445.courses.cs.cmu.edu/fall2021/project4/">PROJECT #4 - CONCURRENCY CONTROL</a></li><li><input disabled="" type="checkbox"> <a href="/2022/06/30/DB_Notes/hello/" title="helloworld">helloworld</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>DataBase</category>
      
      <category>CMU15-445</category>
      
      <category>实验笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Project1 - Buffer Pool</title>
    <link href="/2022/06/28/DB_Notes/project1-Buffer_Pool/"/>
    <url>/2022/06/28/DB_Notes/project1-Buffer_Pool/</url>
    
    <content type="html"><![CDATA[<h1 id="Buffer-Pool实现"><a href="#Buffer-Pool实现" class="headerlink" title="Buffer Pool实现"></a>Buffer Pool实现</h1><h2 id="LRU-Replacer"><a href="#LRU-Replacer" class="headerlink" title="LRU Replacer"></a>LRU Replacer</h2><p>关键数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 用队列来维护replacer中的frame，新来的从头部插入，最旧的在末尾</span><br>std::list&lt;<span class="hljs-type">frame_id_t</span>&gt; queue_;<br><span class="hljs-comment">// 用来存放该frame在queue中的位置，方便当Pin调用时将该frame从replacer队列中移除</span><br>std::unordered_map&lt;<span class="hljs-type">frame_id_t</span>, std::list&lt;<span class="hljs-type">frame_id_t</span>&gt;::iterator&gt; map_;<br></code></pre></td></tr></table></figure><p>关键实现逻辑：</p><ol><li>frame：<strong>frame表示的是buffer_pool中格子的索引</strong>，可以用来存放不同的page，格子总是那么多。<ol><li>所以Victim()表示找到该frame并且新读入的page可以写入该frame</li><li>Pin表示该frame中的page有用，新来的page不要用该frame</li><li>Unpin表示该frame中的page用不上，可以被取代，该frame可写入。</li></ol></li><li>LRU的逻辑：很巧妙，<strong>多次Unpin并不表示该page被新使用了，所以Unpin时如果该frame在replacer中并不需要将该frame提到queue的头部</strong>，该page被访问或者被使用的时候都会调用Pin，而这时候会将该frame移出，所以每次被使用的时候都会移出replacer，<strong>新加入的就会比后面的更晚被使用，因为如果后面的有更新被使用的都从queue中被移除了</strong>。</li></ol><h2 id="Buffer-Pool-Manager"><a href="#Buffer-Pool-Manager" class="headerlink" title="Buffer Pool Manager"></a>Buffer Pool Manager</h2><p>关键数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/** Array of buffer pool pages. 即buffer_pool数组，数组中各个元素指向各个page。该数组的索引即为frame_id*/</span><br>Page *pages_;<br><span class="hljs-comment">/** Page table for keeping track of buffer pool pages. 存放page_id到frame_id的映射*/</span><br>std::unordered_map&lt;<span class="hljs-type">page_id_t</span>, <span class="hljs-type">frame_id_t</span>&gt; page_table_;<br><span class="hljs-comment">/** Replacer to find unpinned pages for replacement. 用来实现page替换算法，上面的LRU是它的子类*/</span><br>Replacer *replacer_;<br><span class="hljs-comment">/** List of free pages. 记录空着的没用的frame*/</span><br>std::list&lt;<span class="hljs-type">frame_id_t</span>&gt; free_list_;<br></code></pre></td></tr></table></figure><p>关键实现逻辑：</p><ol><li>索引：指针数组pages_就是buffer_pool，<strong>它的索引就是frame_id</strong>，表示buffer_pool中的位置。</li><li>放入buffer_pool：就是先从free_list_中找是否有空着的frame，然后再从replacer中找根据替换原则找到下一个可替换写入的frame，找到该frameid后将要new或者读取的page的指针放入该frame中。</li><li>离开buffer_pool：如果该page要被删除，则将该page的数据清除，包括元数据，然后将该frame放入free_list中。如果只是Unpin，则放入replacer等待被替换就好。</li><li>实际实现中，<strong>buffer_pool已经初始化好了各个page的数据结构，读入和卸载都只是修改page的数据和元数据，并不是新建或者消除一个Page对象</strong>。</li><li>跟硬盘数据的交互有一个disk_manager对象来进行磁盘端的读取，删除和写入。</li></ol><h2 id="Parallel-Buffer-Pool-Manager"><a href="#Parallel-Buffer-Pool-Manager" class="headerlink" title="Parallel Buffer Pool Manager"></a>Parallel Buffer Pool Manager</h2><p>关键数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 指针数组，存放指向各个BufferPool的指针</span><br>BufferPoolManagerInstance **bpms_;<br><span class="hljs-comment">// BufferPool的数目</span><br><span class="hljs-type">size_t</span> num_instances_;<br></code></pre></td></tr></table></figure><p>关键实现逻辑：</p><ol><li><p>其实就一个逻辑，根据pageid轮流调用不同的bufferpool，从而分担workload，提高并行度。即将page放在第pageid%num_instances个bufferpool中，类似哈希表。</p></li><li><p>每个buffer_pool都有一个mutex，即latch，在bufferpool的每个函数上加锁来避免多线程带来的问题.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 加锁，并自动释放</span><br>std::scoped_lock lock&#123;latch_&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整体实现还是比较简单，整体就是要弄清楚下面三个问题：</p><ol><li>LRU中，多次Unpin并不表示该page被新使用了，所以Unpin时如果该frame在replacer中并不需要将该frame提到queue的头部。新加入的就会比后面的更晚被使用，因为如果后面的有更新被使用的都从queue中被移除了。</li><li>指针数组pages_就是buffer_pool，<strong>它的索引就是frame_id</strong>，表示buffer_pool中的位置。</li><li>buffer_pool已经初始化好了各个page的数据结构，读入和卸载都只是修改page的数据和元数据，并不是新建或者消除一个Page对象。</li></ol>]]></content>
    
    
    <categories>
      
      <category>DataBase</category>
      
      <category>CMU15-445</category>
      
      <category>实验笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验笔记</tag>
      
      <tag>DataBase</tag>
      
      <tag>CMU15-445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Project2 - Extendible Hash Index</title>
    <link href="/2022/06/28/DB_Notes/project2-Hash_Index/"/>
    <url>/2022/06/28/DB_Notes/project2-Hash_Index/</url>
    
    <content type="html"><![CDATA[<h1 id="Extendible-Hash-Index实现"><a href="#Extendible-Hash-Index实现" class="headerlink" title="Extendible Hash Index实现"></a>Extendible Hash Index实现</h1><p><a href="https://15445.courses.cs.cmu.edu/fall2021/project2/">Project #2 - Extendible Hash Index | CMU 15-445&#x2F;645 :: Intro to Database Systems (Fall 2021)</a></p><p>实现一个hash表用来存储数据。有key和value，hash函数对key生效，使用的xxHash。</p><p>整体结构：一个hash table对象由以下结构组成</p><ol><li>一个directory_page，存储着hashtable元数据，以及索引数组，索引数组存储着该key所在的bucket所在的page的pageid。<strong>它的空间由project 1的buffer_pool分配的Page中的data分配</strong></li><li>很多个bucket_page，存储着数据pair，包括key和value。一个key可以对应多个不同的value，访问时会返回该key的所有value。无需。<strong>它的空间也由project 1的buffer_pool分配的Page中的data分配</strong></li><li>上面两个page都和buffer pool中的page不同，<strong>前者并不是后者的子类。而是buffer pool中的page的data部分存放着这两种page的数据</strong>。</li></ol><p>所以根据结构，我们需要先实现directory_page类和bucket_page类，然后再实现hash_table类，通过调用前两个类来实现这个类。</p><h2 id="Hash-Table-Directory-Page"><a href="#Hash-Table-Directory-Page" class="headerlink" title="Hash Table Directory Page"></a>Hash Table Directory Page</h2><p>根据对key的hash快速索引找到存储目标value的page。读取page的data并根据key找到目标。</p><h3 id="关键数据结构："><a href="#关键数据结构：" class="headerlink" title="关键数据结构："></a>关键数据结构：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 存储当前的global depth</span><br><span class="hljs-type">uint32_t</span> global_depth_&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">// 存储各个bucket的localdepth</span><br><span class="hljs-type">uint8_t</span> local_depths_[DIRECTORY_ARRAY_SIZE];<br><span class="hljs-comment">// 存储各个bucket所在的pageid</span><br><span class="hljs-type">page_id_t</span> bucket_page_ids_[DIRECTORY_ARRAY_SIZE];<br></code></pre></td></tr></table></figure><h3 id="关键实现逻辑："><a href="#关键实现逻辑：" class="headerlink" title="关键实现逻辑："></a>关键实现逻辑：</h3><ol><li><mark>hash索引</mark>：先对key进行hash，再取得到的值的后<em>global_depth</em>位，这就相当于mod directory的当前长度。<strong>我这里实现取低位，即least-significant bits（LSB）</strong>。</li><li>IncrGlobalDepth: 将dir数组扩充为原来的两倍，<strong>由于新的一半都是旧的一半的兄弟（即在上一个global_depth时索引相等）</strong>，所以直接让新的一半的local_depth和bucket_page都复制旧的一半就好了。</li><li>DecrGlobalDepth: <strong>直接减小global_depth就可以</strong>，就会失去对另一半的访问，相当于释放了。没有对数组进行操作。</li><li>SetBucketPageId：<ol><li>首先需要检查要设置的bucket_idx是否超过了dir的范围，如果是则需要增大global_depth。</li><li>而且由于调用时，肯定是需要将该bucket指向与原本不同的page，所以需要增大自己和当前兄弟（指向同一个旧page）的localdepth（IncrLocalDepth中直接实现了这部分逻辑）。</li><li>然后设置该bucket的pageid时，<strong>需要根据新的localdepth，找到当前的所有兄弟并将新pageid赋给这些兄弟</strong>。</li></ol></li><li>IncrLocalDepth: 增大自己<strong>和当前兄弟（指向同一个旧page）的localdepth</strong>。</li><li>GetOldBro: 找到（global_depth_-1）时的兄弟bucket，在merge时调用。<strong>只需要取后global_depth_位（bucket_idx直接就是）并将local_depth_位取反就找到了</strong>。</li><li>CanShrink: 表示dir可以缩小规模，如果是则直接DecrGlobalDepth。只需要判断是不是每个localdepth都小于global_depth就行。</li><li><mark>Merge</mark>: 在hash table的RemoveMerge中调用，即一个page被删空了，可以和他的oldbro进行合并，指向同一个page。<strong>需要让每一个指向旧page(已经空了)的bucket都指向新page，并且让所有指向新page的localdepth-1，因为他们之前都是兄弟</strong>。在最后用Canshrink检查dir是否可以收缩，如果是则globaldepth减小。</li></ol><h2 id="Hash-Table-Bucket-Page"><a href="#Hash-Table-Bucket-Page" class="headerlink" title="Hash Table Bucket Page"></a>Hash Table Bucket Page</h2><p>存放在page的data中。用来存储数据pair，无序，直接就是一个个pair放在数组中。访问的时候直接遍历bucket寻找。</p><h3 id="关键数据结构：-1"><a href="#关键数据结构：-1" class="headerlink" title="关键数据结构："></a>关键数据结构：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 位图，该bit为1表示该位置曾经被写入过，作用不大</span><br><span class="hljs-type">char</span> occupied_[(BUCKET_ARRAY_SIZE - <span class="hljs-number">1</span>) / <span class="hljs-number">8</span> + <span class="hljs-number">1</span>];<br><span class="hljs-comment">// 位图，该bit为1表示该位置的值有效（即可读取使用）</span><br><span class="hljs-type">char</span> readable_[(BUCKET_ARRAY_SIZE - <span class="hljs-number">1</span>) / <span class="hljs-number">8</span> + <span class="hljs-number">1</span>];<br><span class="hljs-comment">// 存储pair，key</span><br>MappingType array_[BUCKET_ARRAY_SIZE];<br></code></pre></td></tr></table></figure><h3 id="关键实现逻辑"><a href="#关键实现逻辑" class="headerlink" title="关键实现逻辑"></a>关键实现逻辑</h3><ol><li><p>IsReadable和SetReadable:前者判断该位是否为1，后者将该位置1。<strong>Readable就表示该位置的pair是有效的存在的，否则就是被删除了，不应该被读取</strong>。</p></li><li><p>GetValue: 直接遍历array_，对所有Readable的位置进行key的比较，如果相等则加入到结果数组中。</p></li><li><p>Insert: 需要遍历所有的readable判断是否有key和value都一样的。同时找到合适的插入位置。</p></li><li><p>Remove: 找到目标pair的位置，<strong>然后在readable中将该位置置为0就好，并不需要实际的删除</strong>。</p></li><li><p>IsFull和IsEmpty: 两者类似，都先判断一整个char（8位）。<strong>需要注意的是，全1为-1，全0等于0，有1不一定大于0，因为用的是补码表示</strong>。</p></li></ol><h2 id="Extendible-Hash-Table"><a href="#Extendible-Hash-Table" class="headerlink" title="Extendible Hash Table"></a>Extendible Hash Table</h2><p>调用上面实现的directory和bucket实现Extendible Hash Table.</p><h3 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 存放directory的page</span><br><span class="hljs-type">page_id_t</span> directory_page_id_;<br><span class="hljs-comment">// buffer pool对象，用来管理page</span><br>BufferPoolManager *buffer_pool_manager_;<br><span class="hljs-comment">// key比较器</span><br>KeyComparator comparator_;<br><span class="hljs-comment">// Readers includes inserts and removes, writers are splits and merges</span><br>ReaderWriterLatch table_latch_;<br></code></pre></td></tr></table></figure><h3 id="关键实现逻辑-1"><a href="#关键实现逻辑-1" class="headerlink" title="关键实现逻辑"></a>关键实现逻辑</h3><ol><li><p>初始化：首先创建一个page用来存放directory_page，并将pageid赋值给<em>directory_page_id</em>。接着创建一个bucke_page，让dir中的bucket0指向它。</p></li><li><p>从buffer_pool中获得page：**从buffer_pool中得到的page是缓冲池中的page，并不是hash table中directory page或者bucket page的父类，hash table的各个page应该放在page的data部分，所以要用GetData()**。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将Page*转化为HashTableDirectoryPage *就不行，因为前者并不是后者的父类，也不是相同的结构</span><br>HashTableDirectoryPage * dir_page = <span class="hljs-built_in">reinterpret_cast</span>&lt;HashTableDirectoryPage *&gt;(buffer_pool_manager_-&gt;<span class="hljs-built_in">FetchPage</span>(directory_page_id_));<br><span class="hljs-comment">// 强制转换的指针是data部分，而不是整个buffer pool 中管理的page</span><br>HashTableDirectoryPage * dir_page = <span class="hljs-built_in">reinterpret_cast</span>&lt;HashTableDirectoryPage *&gt;(buffer_pool_manager_-&gt;<span class="hljs-built_in">FetchPage</span>(directory_page_id_)-&gt;<span class="hljs-built_in">GetData</span>());<br></code></pre></td></tr></table></figure></li><li><p>GetValue: 没有什么特别的。根据key，在dir中找到bucket对应的page，读如然后调用该bucekt_page的GetValue就好。</p></li><li><p>Insert: 根据key找到要插入的bucket_page，检查有没有重复的，检查有没有位置，如果可以就插入，如果满了调用SplitInsert。</p></li><li><p>SplitInsert: 创建一个新的bucekt_page，并将要插入的pair插入。接着调用dir提供的SetBucketPage(会同步更新兄弟的page和depth)。然后遍历旧的bucket_page，将上面的pairs分流到旧page和新page中。 注意，<strong>由于已经更新了dir，所以分流时只需要关注该pair要进入的page是哪一个就行</strong>，不用管bucket_idx。注意，SplitInert一定要再次检查page是否满或者是否有相同的，<strong>即后续操作和检查操作一定要在一组锁中，不能分别在两个阶段的锁中</strong>，否则会出现多线程的问题！</p></li><li><p>Remove: 找到目标pair删除即可。</p></li><li><p>RemoveMerge: 删除后bucket_page为空时，且localdepth&gt;0且old_bro的localdepth和自己相等时调用。首先将自己的bucket_page删除。然后调用dirpage提供的merge方法，使自己和兄弟共同指向oldbro的bucket_page并更新localdepth。同样要注意，<strong>检查和merge操作要在一组锁中，不能分成两阶段，否则多线程出错</strong>。并且，<strong>还需要检查新合并的page是否也为空，如果是则需要递归的检查是否可以进行shrink</strong>。否则可能出现删空了但是globaldepth不为0的情况。</p></li></ol><h2 id="其他注意点"><a href="#其他注意点" class="headerlink" title="其他注意点"></a>其他注意点</h2><ol><li><p>FetchPage后一定要及时的UnpinPage，否则可能导致buffer_pool不够用。</p></li><li><p>table_latch主要控制对于directory的读写，bucket_page的读写控制需要用Page提供的rwlatch。即需要获得Page*来进行读写锁控制，然后再将Page的data转化为bucketpage类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Page *father_page = <span class="hljs-built_in">FetchBucketPage</span>(bucket_page_id);<br>father_page-&gt;<span class="hljs-built_in">RLatch</span>();<br>HASH_TABLE_BUCKET_TYPE *bucket_page = <span class="hljs-built_in">reinterpret_cast</span>&lt;HASH_TABLE_BUCKET_TYPE *&gt;(father_page-&gt;<span class="hljs-built_in">GetData</span>());<br><span class="hljs-type">bool</span> ret = bucket_page-&gt;<span class="hljs-built_in">GetValue</span>(key, comparator_, result);<br>father_page-&gt;<span class="hljs-built_in">RUnlatch</span>();<br><span class="hljs-comment">// 释放page</span><br><span class="hljs-built_in">UnpinPage</span>(bucket_page_id, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>锁应该嵌套的获取和释放</strong>。即先获取的锁应该后释放，而不能先获取的锁先释放。否则会发生死锁。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>从buffer_pool中得到的page是缓冲池中的page，并不是hash table中directory page或者bucket page的父类，hash table的各个page应该放在page的data部分，所以要用GetData()。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将Page*转化为HashTableDirectoryPage *就不行，因为前者并不是后者的父类，也不是相同的结构</span><br>HashTableDirectoryPage * dir_page = <span class="hljs-built_in">reinterpret_cast</span>&lt;HashTableDirectoryPage *&gt;(buffer_pool_manager_-&gt;<span class="hljs-built_in">FetchPage</span>(directory_page_id_));<br><span class="hljs-comment">// 强制转换的指针是data部分，而不是整个buffer pool 中管理的page</span><br>HashTableDirectoryPage * dir_page = <span class="hljs-built_in">reinterpret_cast</span>&lt;HashTableDirectoryPage *&gt;(buffer_pool_manager_-&gt;<span class="hljs-built_in">FetchPage</span>(directory_page_id_)-&gt;<span class="hljs-built_in">GetData</span>());<br></code></pre></td></tr></table></figure></li><li><p>unsigned int 不能用 &gt;&#x3D; 0 来循环，因为永远大于0</p></li><li><p>int可以转成unsigned int，反之则能，会出错（测试中是总是会小1）。</p></li><li><p>c&#x2F;c++中，char 全为1的时候等于-1，而不是255，因为是有符号整数，8位 ，表示范围是-128-127，补码表示。顺便复习一下补码的知识。<a href="https://zhuanlan.zhihu.com/p/99082236">二进制的原码、反码、补码</a>对于负数，补码相当于求该负数的同余正数（即-2%256&#x3D;254)，所以-2的补码就是254。符号位刚好也成了1。</p></li><li><p>在bucket page的IsFull()和IsEmpty()中都用到了4的知识，一定要注意！</p></li><li><p>关于锁，一定要注意锁的使用，避免死锁发生：</p><ol><li>锁应该嵌套的获取和释放。即先获取的锁应该后释放，而不能先获取的锁先释放。</li><li>在splitinsert中，hadsame的检查一定要和分流在同一个锁中，不能进行分段。</li></ol></li><li><p>Merge和shrink后，有可能还可以进行merge和shrink，即merge后的指向的新page有可能还是空的。所以需要递归继续合并。否则可能删除完后最后globaldepth还是非0。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>DataBase</category>
      
      <category>CMU15-445</category>
      
      <category>实验笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验笔记</tag>
      
      <tag>DataBase</tag>
      
      <tag>CMU15-445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷题笔记</title>
    <link href="/2022/06/24/cppLearning/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/06/24/cppLearning/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="刷题笔记"><a href="#刷题笔记" class="headerlink" title="刷题笔记"></a>刷题笔记</h1><h2 id="易忘点"><a href="#易忘点" class="headerlink" title="易忘点"></a>易忘点</h2><h3 id="c-基本数据类型及其宏定义"><a href="#c-基本数据类型及其宏定义" class="headerlink" title="c++基本数据类型及其宏定义"></a>c++基本数据类型及其宏定义</h3><p><img src="C:\Users\Godlight666\AppData\Roaming\Typora\typora-user-images\image-20220308110411406.png" alt="image-20220308110411406"></p><p><img src="C:\Users\Godlight666\AppData\Roaming\Typora\typora-user-images\image-20220308110447651.png" alt="image-20220308110447651"></p><h3 id="创建对象的几种方式"><a href="#创建对象的几种方式" class="headerlink" title="创建对象的几种方式"></a>创建对象的几种方式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//显式创建</span><br><span class="hljs-comment">//会创建一个临时对象，然后将临时对象复制到person中，并丢弃临时对象。此时，将为临时对象调用析构函数</span><br>Person person = <span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;ker&quot;</span>,<span class="hljs-number">23</span>);<br><span class="hljs-comment">//隐式调用</span><br><span class="hljs-comment">//与上面一样，只是换一种格式</span><br><span class="hljs-function">Person <span class="hljs-title">person</span><span class="hljs-params">(<span class="hljs-string">&quot;ker&quot;</span>,<span class="hljs-number">23</span>)</span></span>;<br><span class="hljs-comment">//使用默认构造函数显式调用</span><br>Person person = <span class="hljs-built_in">Person</span>();<br><span class="hljs-comment">//使用默认构造函数隐式调用</span><br>Person person;<br><br><span class="hljs-comment">//上面的方式都是得到的对象，创建时会生成临时对象，空间分配在栈中</span><br><span class="hljs-comment">//使用new关键字是会调用malloc在堆中分配空间，需要我们自己释放</span><br>Person* person = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;ker&quot;</span>,<span class="hljs-number">123</span>);<br><span class="hljs-comment">//用了new一定记得delete</span><br><span class="hljs-keyword">delete</span> person;<br></code></pre></td></tr></table></figure><h3 id="vector的操作"><a href="#vector的操作" class="headerlink" title="vector的操作"></a>vector的操作</h3><ol><li>size()</li><li>front(), back()</li><li>push_back(), emplace_back()</li><li>erase(iterator), 例如：myvector.erase (myvector.begin()+5);</li><li>pop_back()</li></ol><h3 id="string的常用操作"><a href="#string的常用操作" class="headerlink" title="string的常用操作"></a>string的常用操作</h3><ol><li>[]</li><li>append() &#x2F;&#x2F;添加string</li><li>push_back()&#x2F;&#x2F;添加char</li><li>std::stoi()&#x2F;&#x2F;转化成int</li><li>std::to_string(。。。)&#x2F;&#x2F;其他转化成string</li><li>erase()&#x2F;&#x2F;删除</li><li>+&#x3D;</li><li><ul><li></li></ul></li><li>sutstr(a,b)。取子串，a为子串起始位置，<strong>b为子串长度</strong>，b可以为空，则默认取到字符串末尾。</li></ol><h3 id="priority-queue的操作"><a href="#priority-queue的操作" class="headerlink" title="priority_queue的操作"></a>priority_queue的操作</h3><ol><li><p>构造</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">priority_queue&lt;<span class="hljs-keyword">typename</span>,container&lt;<span class="hljs-keyword">typename</span>&gt;,<span class="hljs-function">compare&lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-title">queue</span><span class="hljs-params">(it.begin(),it.end())</span></span><br><span class="hljs-function">priority_queue&lt;Type, Container, Functional&gt;</span><br><span class="hljs-function"><span class="hljs-comment">//例如</span></span><br><span class="hljs-function">priority_queue&lt;MyStruct,vector&lt;MyStruct&gt;,less&lt;MyStruct&gt;&gt; <span class="hljs-title">queue</span><span class="hljs-params">(it.begin(),it.end())</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//对于compare，可以用自己的比较方式，有两种方法</span></span><br><span class="hljs-function"><span class="hljs-comment">//对于自己构建的类，比如MyStruct，可以在MyStruct中overload操作符&lt;，相当于less&lt;MyStruct&gt;中less会调用MyStruct操作符&lt;来进行比较</span></span><br><span class="hljs-function"><span class="hljs-comment">//注意这两个const一定不能少，少了就不对了</span></span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; <span class="hljs-params">(<span class="hljs-type">const</span> MyStruct&amp; s)</span> <span class="hljs-type">const</span></span>&#123;<br><br>&#125;<br>priority_queue&lt;MyStruct&gt; queue;<br><span class="hljs-comment">//也可以自己构建一个compare类（function-like class），这个类需要覆写operator（）来实现比较</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cmp</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(MyStruct s1,MyStruct s2)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> s1.time&lt;s2.time;<br>    &#125;<br>&#125;<br>priority_queue&lt;MyStruct,vector&lt;MyStruct&gt;,cmp&gt; queue;<br></code></pre></td></tr></table></figure></li><li><p>基本操作</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">queue</span>.emplace(<span class="hljs-params">...</span>);<br><span class="hljs-built_in">queue</span>.top();<br><span class="hljs-built_in">queue</span>.pop();<br><span class="hljs-built_in">queue</span>.push();<br><span class="hljs-built_in">queue</span>.size();<br></code></pre></td></tr></table></figure></li></ol><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ol><li>pop()并不会返回top值。</li><li>multiset和multimap的erase(obj)函数会擦除所有找到的，只有使用erase(iterator it)才会擦除指定的一个</li><li>sort默认是从小到大排序，<strong>priority_queue默认是从大到小排序</strong>。</li><li>对于一个类，如果自己实现了构造函数，则编译器不会再自动添加无参构造函数了，<strong>必须自己显式声明</strong></li><li>static函数（成员）<strong>不能加const</strong></li><li>vector初始化时指定了大小后，再用push_back()会加到长度之外，记得用[]访问修改</li></ol><h3 id="一些常用函数"><a href="#一些常用函数" class="headerlink" title="一些常用函数"></a>一些常用函数</h3><ol><li><p>std::stoi(string str)：字符串转int</p></li><li><p>std::reverse(iterator begin,iterator end)：反转，可以用来反转字符串</p></li><li><p>#include<locale>  isalnum(int c); 判断输入是否字符是数字或者大小写字母</p></li><li><p>初始化二维vector(r*c,初始值为0）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">newOne</span>(r, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(c, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure></li><li><p>sort使用自定义逻辑</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//自定义函数，下面是比较int的，返回bool值，true为前者小于后者，false为前者大于等于后者</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myfun</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-keyword">return</span> a&lt;b;&#125;<br><br><span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(),arr.<span class="hljs-built_in">end</span>(),myfun)<br></code></pre></td></tr></table></figure></li><li><p>整数除法向上取整</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">11</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> c = (a+b<span class="hljs-number">-1</span>)/b;<span class="hljs-comment">//6</span><br>c = <span class="hljs-built_in">ceil</span>(a/b);<span class="hljs-comment">//5</span><br>c = <span class="hljs-built_in">ceil</span>((<span class="hljs-type">double</span>)a/b);<span class="hljs-comment">//6</span><br></code></pre></td></tr></table></figure></li><li></li></ol><h2 id="循环用快慢指针"><a href="#循环用快慢指针" class="headerlink" title="循环用快慢指针"></a>循环用快慢指针</h2><ol><li><p>看到判断是否有循环，就可以考虑快慢指针</p></li><li><p>判断循环的入口，考虑用数学思维。（142. 环形链表）</p><p>面试题 02.07. 链表相交 也考虑用数学规律</p></li><li><p>不只有链表，(<a href="https://leetcode-cn.com/problems/happy-number/">202. 快乐数</a>)也可以用快慢指针，需要判断循环点是什么。</p></li></ol><h2 id="几数之和"><a href="#几数之和" class="headerlink" title="几数之和"></a>几数之和</h2><ol><li>如果要求是几个数的下标，则不能排序，这需要用map或set记录。（1. 两数之和）</li><li>如果只是需要数的值，，则可以用排序，这时候考虑双指针。其他指针固定，两个指针动。（ 第15题. 三数之和，第18题. 四数之和）</li></ol><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><ol><li>239.滑动窗口最大值题，维护一个单调队列，队头的值一直为最大值，并单调递减，队列中不存在位置在队头前的数，</li></ol><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ol><li>迭代式遍历，一个节点一开始放进去并不会读取，只是用来加入其它的节点，并在该节点上方加一个标记(nullptr)，第二次读到的时候从栈中弹出。如下是中序遍历，其它遍历只需要变更顺序就好了</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        stack&lt;TreeNode*&gt; stack;<br>        stack.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>())&#123;<br>            TreeNode* cur = stack.<span class="hljs-built_in">top</span>();<br>            stack.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">nullptr</span>)&#123;<br>                TreeNode* n = stack.<span class="hljs-built_in">top</span>();<br>                stack.<span class="hljs-built_in">pop</span>();<br>                res.<span class="hljs-built_in">push_back</span>(n-&gt;val);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span> (cur-&gt;right != <span class="hljs-literal">nullptr</span>)&#123;<br>                    stack.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                &#125;<br>                stack.<span class="hljs-built_in">push</span>(cur);<br>                stack.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>);<br>                <span class="hljs-keyword">if</span> (cur-&gt;left != <span class="hljs-literal">nullptr</span>)&#123;<br>                    stack.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125; <br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li>层序遍历模板，用一个队列</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs arduino">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        queue&lt;TreeNode*&gt; queue;<br>        queue.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>        <span class="hljs-keyword">while</span> (!queue.<span class="hljs-built_in">empty</span>())&#123;<br>            temp = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;();<br>            <span class="hljs-comment">//相当于遍历当前层</span><br>            <span class="hljs-type">int</span> size = queue.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;++i)&#123;<br>                TreeNode* cur = queue.<span class="hljs-built_in">front</span>();<br>                queue.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">//在这里进行操作，根据题目意思来</span><br>                temp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-comment">//把下一层节点添加进去</span><br>                <span class="hljs-keyword">if</span> (cur-&gt;left!=<span class="hljs-literal">nullptr</span>)&#123;<br>                    queue.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (cur-&gt;right!=<span class="hljs-literal">nullptr</span>)&#123;<br>                    queue.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                &#125;<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><ol><li>特征：左子树小，右子树大，相当于二分法，log时间复杂度，<strong>中序遍历为递增序列</strong>。</li><li>98.验证二叉搜索树，中，<strong>注意陷阱，不能只用root比较left和right</strong>，否则left的right可能比left的root大，就不合理。可以用中序遍历的思想，用一个全局变量记录pre，永远比pre大就行。</li><li>利用中序遍历有序的性质的题：98，530,501</li></ol><h3 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h3><ol><li>LeetCode236. 二叉树的最近公共祖先。使用后序遍历，如果左子树和右子树都有目标节点，说明当前节点就是最近公共祖先，就返回，如果只有一边有，就返回一边的，如果都没有，就返回null。</li><li>LeetCode235. 二叉搜索树的最近公共祖先。二叉搜索树有一个特性，最近公共祖先的祖先肯定数值范围在目标范围之外（因为公共祖先所在的树肯定只是一边，就都比它小或者大，就不会在范围之间），所以从上往下找，只要在范围之间就是最近公共祖先。</li></ol><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ol><li>701.二叉搜索树中的插入操作。插入只需要用前序遍历，一直找到一个合适的叶子节点的位置插入就行。</li><li><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450.删除二叉搜索树中的节点</a>考虑用递归的方式，前序遍历，每次递归返回当前树的头结点，把左子树加到右子树的最左节点上。</li><li><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a>同上一题类似，并且可以利用有序性，一次性直接舍去左子树&#x2F;右子树。</li></ol><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><ol><li><p>回溯模板</p></li><li><p>对于组合问题，为了避免重复，可以考虑使用startindex，即之后的遍历都从当前index（或者index+1，区别在能不能重复使用）开始，前面的就不用了，就能避免重复。典型问题有<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合 </a>、<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III</a>和<a href="https://leetcode-cn.com/problems/combination-sum/">39.组合总和</a></p></li><li><p>当候选列表中有重复元素时，为了避免选出的组合重复，需要在树的同一层选择的时候进行去重（比如先对数组排序，然后同一层与前一个元素相同就跳过），也即在一次选择中不选相同的，每次选择都这样就能避免选出相同的组合。比如<a href="https://leetcode-cn.com/problems/combination-sum-ii/">40.数组总和II</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//同一层的选择遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=index;i&lt;candidates.<span class="hljs-built_in">size</span>();++i)&#123;<br><span class="hljs-comment">//跳过相同的元素，candidates是有序的。</span><br><span class="hljs-comment">//注意：是大于index而不是大于0，这样才是在比较同一层元素</span><br><span class="hljs-keyword">if</span> (i &gt; index&amp;&amp;candidates[i]==candidates[i<span class="hljs-number">-1</span>])&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-comment">//常规回溯流程</span><br>temp.<span class="hljs-built_in">push_back</span>(candidates[i]);<br><span class="hljs-built_in">backTrack</span>(candidates,sum+candidates[i],i+<span class="hljs-number">1</span>,temp);<br>temp.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>与组合问题不同，<a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131.分割回文串</a>和<a href="https://leetcode-cn.com/problems/restore-ip-addresses/">93.复原IP地址</a>等题目，每一次的（一层中）的选择不是选择哪一个，而是选择多少个（连续的），所以需要转化思路，每一层的选择是选择连续多少个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//131题部分节选</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=index;i&lt;s.<span class="hljs-built_in">size</span>();++i)&#123;<br>    <span class="hljs-comment">//并不pop，因为是要选择连续多少个</span><br>temp.<span class="hljs-built_in">push_back</span>(s[i]);<br>    <span class="hljs-comment">//符合条件就加入</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isTarget</span>(temp))&#123;<br>ve.<span class="hljs-built_in">emplace_back</span>(temp);<br><span class="hljs-built_in">backTrack</span>(s,i+<span class="hljs-number">1</span>,ve,len+temp.<span class="hljs-built_in">size</span>());<br>ve.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><ol><li>在<a href="https://leetcode-cn.com/problems/candy/">135.分发糖果</a>中，对于局部既需要考虑左侧又需要考虑右侧时，可以考虑先只考虑与左侧比（从前往后遍历），再考虑与右侧比（从后往前遍历），分开考虑。<a href="https://leetcode-cn.com/problems/shortest-distance-to-a-character/">821.字符串的最短距离</a>也是这种思路。</li><li>在<a href="https://leetcode-cn.com/problems/gas-station/">134.加油站</a>中，先考虑整体是否能够走完（用一个变量累加全局，要是是负数说明走不完），然后再全局能走完的情况下，思考起点。对于起点，如果(i,j)区间内的累加值为负数，则起点可能不在其中，就可以从j+1开始考虑。</li><li>在<a href="https://leetcode.cn/problems/di-string-match/">942. 增减字符串匹配</a>中，不用使用回溯算法，直接每次选可选的最大的或者最小的就行。</li></ol><h2 id="不会做的题"><a href="#不会做的题" class="headerlink" title="不会做的题"></a>不会做的题</h2><ol><li><p>190.颠倒二进制位</p></li><li><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96.不同的二叉搜索树</a>用动态规划，只用考虑形状</p></li><li><h4 id="812-最大三角形面积根据数学知识，三角形面积等于两条边向量叉乘-x2F-2"><a href="#812-最大三角形面积根据数学知识，三角形面积等于两条边向量叉乘-x2F-2" class="headerlink" title="812. 最大三角形面积根据数学知识，三角形面积等于两条边向量叉乘&#x2F;2."></a><a href="https://leetcode.cn/problems/largest-triangle-area/">812. 最大三角形面积</a>根据数学知识，三角形面积等于两条边向量叉乘&#x2F;2.</h4></li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
